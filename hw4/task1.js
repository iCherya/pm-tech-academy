/* 
- Конкатенация слева и справа, так как есть строки => слева -> '22' | справа -> '22'
- Сравниваем строки ('22' === '22'), они равны, поэтому результат => true
*/
console.log(2 + '2' == '2' + 2); // true

/* 
- Конкатенация слева и справа, так как есть строки: слева -> '23' | справа -> '32'
- Сравниваем строки ('23' === '32'), они не равны, поэтому результат => false
*/
console.log(2 + '3' == '3' + 2); // false

/* 
- Конкатенация слева, так как строки. Справа сложение: слева -> '32' | справа -> 5
- Сравниваем разные типы, поэтому осуществляется приведение к числу строки '32'
- Сравниеваем числа (32 === 5), они не равны, поэтому результат => false
*/
console.log('3' + '2' == 3 + 2); // false

/* 
- Конкатенация слева и справа, так как есть строки: слева -> '32' | справа -> '32'
- Сравниваем строки ('32' === '32'), они равны, поэтому результат => true
*/
console.log('3' + '2' == '3' + 2); // true

/* 
- Конкатенация слева и справа, так как есть строки: слева -> '32' | справа -> '23'
- Сравниваем строки ('32' === '23'), они не равны, поэтому результат => false
*/
console.log('3' + '2' == 2 + '3'); // false

/* 
- Явное приведение к числу слева и справа: слева -> 2 + 3 | справа -> 3 + 2
- Сравниваем числа (5 === 5), они равны, поэтому результат => true
*/
console.log(2 + Number('3') == Number('3') + 2); // true

/* 
- Математическое деление, значит преобразование к числу строки '6'
- 12 / 6 = 2, поэтому результат 2
*/
console.log(12 / '6'); // 2

/* 
- Первым значением идет строка, поэтому осуществится конкатенация на каждом операнде: 
- 'number' + 15 + 3 => 'number15' + 3 => 'number153'
*/
console.log('number' + 15 + 3); // 'number153'

/* 
- Сначала оператор +, выполнит сложение первых двух чисел => 18 + 'number'
- Затем конкатенация, так как третьей стоит строка, поэтому результат => '18number'
*/
console.log(15 + 3 + 'number'); // '18number'

/* 
- Операнд слева объект, поэтому осущесвляется приведение к примитиву. 
- Сравнение разных типов, поэтому приведение к числу: слева -> 1 | справа -> 0
- Затем (1 > 0), поэтому результат => true
*/
console.log([1] > null); // true

/* 
- Между операторами + нету операнда, поэтому + принимается как унарный (который приводит к числу)
- Поэтому сначала осуществится приведение второго операнда к числу: +'bar' => NaN
- Затем, т.к. первым стоит строка, будет конкатенация, поэтому результат => 'fooNaN'
*/
console.log('foo' + +'bar'); // 'fooNaN'

/* 
- Сравнение разных типов, поэтому произойдет приведение к числу: слева -> NaN | справа -> 1
- Операнды не равны, поэтому результат => false
*/
console.log('true' == true); // false

/* 
- Сравнение разных типов, поэтому произойдет приведение к числу: слева -> 0 | справа -> NaN
- Операнды не равны, поэтому результат => false
*/
console.log(false == 'false'); // false

/* 
- Сравнения (null == null) и (null == undefined) возвратят true 
- Во всех других случаях не строгое сравние с null возвратит false, поэтому результат => false
*/
console.log(null == ''); // false

/* 
- Двойной восклицательный знак приводит к булевому типу. 
- Слева и справа мы приводим не пустые строки, поэтому: (true === true) => true
*/
console.log(!!'false' == !!'true'); // true

/* 
- Массив является объектом, следовательно слева осуществляется преобразование к примитиву
- Слева и справа стороки, поэтому их сравниваем ('x' === 'x'), строки равны, поэтому => true
*/
console.log([`x`] == `x`); // true
